# 12장. 모든 웹 개발자가 관심을 가져야 할 핵심 웹 지표
웹서비스의 성능을 객관적으로 평가할 수 있는 지표인 핵심 웹 지표에 대해 알아보고, 이를 리액트 애플리케이션에서 측정하는 방법을 알아보자.

- [12.1 웹사이트와 성능](#12.1-웹사이트와-성능)
- [12.2 핵심 웹 지표란?](#12.2-핵심-웹-지표란?)
- [12.3 최대 콘텐츠풀 페인트(LCP)](#12.3-최대-콘텐츠풀-페인트(LCP))
    - [12.3.1 정의](#12.3.1-정의)
    - [12.3.2 의미](#12.3.2-의미)
    - [12.3.2 예제](#12.3.2-예제)
    - [12.3.4 기준 점수](#12.3.4-기준-점수)
    - [12.3.5 개선 방안](#12.3.5-개선-방안)
- [12.4 최초 입력 지연(FID)](#12.4-최초-입력-지연(FID))
    - [12.4.1 정의](#12.4.1-정의)
    - [12.4.2 의미](#12.4.2-의미)
    - [12.4.2 예제](#12.4.2-예제)
    - [12.4.4 기준 점수](#12.4.4-기준-점수)
    - [12.4.5 개선 방안](#12.4.5-개선-방안)
- [12.5 누적 레이아웃 이동(CLS)](#12.5-누적-레이아웃-이동(CLS))
    - [12.5.1 정의](#12.5.1-정의)
    - [12.5.2 의미](#12.5.2-의미)
    - [12.5.2 예제](#12.5.2-예제)
    - [12.5.4 기준 점수](#12.5.4-기준-점수)
    - [12.5.5 개선 방안](#12.5.5-개선-방안)
    - [12.5.6 핵심 웹 지표는 아니지만 성능 확인에 중요한 지표들](#12.5.6-핵심-웹-지표는-아니지만-성능-확인에-중요한-지표들)
- [12.6 정리](#12.6-정리)


## 12.1 웹사이트와 성능
사용자가 기대하는 사항
1. 접근성 - 웹사이트를 방문한 목적을 손쉽게 달성할 수 있어야 한다.
2. 속도 - 첫 번째 목적을 달성하는데 걸리는 시간이 짧아야 한다.
3. 보안 - 개인정보가 누출되는 등의 사고 없이 보안이 철저해야 한다.

## 12.2 핵심 웹 지표란?
구글에서 만든 지표로, 웹사이트에서 뛰어난 사용자 경험을 제공하는 데 필수적인 지표를 일컫는 용어
- 최대 콘텐츠풀 페인드(LCP: Largest Contentful Paint)
- 최초 입력 지연(FID: First Input Delay)
- 누적 레이아웃 이동(CLS: Cumulative Layoiut Shift)

그리고 다음 두 지표는 핵심까지는 아니지만, 특정 문제를 진단하는 데 사용될 수 있다.
- 최초 바이트까지의 시간(TTFB: Time To First Byte)
- 최초 콘텐츠풀 시간(FCP: First Contentful Paint)

## 12.3 최대 콘텐츠풀 페인트(LCP)
### 12.3.1 정의
페이지가 처음으로 로드를 시작한 시점부터 **뷰포트 내부에서 가장 큰 이미지 또는 텍스트를 렌더링하는 데 걸리는 시간**

- 뷰포트: 사용자에게 현재 노출되는 화면, 기기마다 다르다.

- 큰 이미지와 텍스트: 
    ```
    - <img>
    - <svg> 내부의 <image>
    - poster 속성을 사용하는 <video>
    - url()을 통해 불러온 배경 이미지가 있는 요소
    - 텍스트와 같이 인라인 텍스트 요소를 포함하고 있는 블록 레벨 요소(<p>, <div> 등)
    ```

=> 즉. 최대 콘텐츠풀 페인트랑 사용자의 기기가 노출하는 뷰포트 내부에서 가장 큰 영역을 차지하는 요소가 렌더링되는 데 얼마나 걸리는지 측정하는 지표다.

### 12.3.2 의미
'웹페이지가 로딩이 완료되어 사용자에게 노출되기까지 걸리는 시간'의 기준은 무엇일까?

개발자에게 가장 먼저 떠오르는 방법은 DOMContentLoaded 이벤트가 호출되는 시간일 것이다.

DOMContentLoaded는 HTML문서를 완전히 불러오고 파싱했을 때 발생하는 이벤트로, 페이지의 document를 대상으로 일어나며 단 한 번만 호출된다.

그러나 이것이 사용자 또한 페이지가 로딩됐다고 인식하기엔 무리가 있다. 왜냐하면 DOMContentLoaded 이벤트는 '스타일시트, 이미지, 하위 프레임의 로딩은 기다리지 않는다'는 제한이 있기 때문이다.

사용자에게 있어 로딩은 뷰포트 영억에 보이는 부분을 기준일 것이다.

=> 사용자에게 페이지의 정보를 화면에 전달하는 속도를 객관적으로 판단하기 위한 지표로 만들어진 것이 LCP다.

### 12.3.3 예제
LCP는 페이지 로딩에 따라 변화하는 지표다.

### 12.3.4 기준 점수
LCP에서 좋은 점수란 해당 지표가 **2.5초 내**로 응답이 오는 것이다.

### 12.3.5 개선 방안
#### 텍스트는 언제나 옳다.
LCP지표에서 좋은 점수를 얻는 가장 확실한 방법은 뷰포트 최대 영역에 이미지가 아닌 문자열을 넣는 것이다.

아무리 이미지를 최적화하더라도 추가적인 리소스 다운로드가 필요한 이미지보다 텍스트 노출이 훨씬 더 빠르다.

#### 이미지는 어떻게 불러올 것인가?
1. img
2. svg
3. video.poster
4. background-img: url()

이미지 로딩 속도는 1번, 3번이 더 빠르게 완성된다.

#### 그 밖에 조심해야 할 사항
- 이미지 무손실 압축
- loading=lazy 주의
- fadein과 같은 각종 애니메이션
- 클라이언트에서 빌드하지 말 것
- 최대 콘텐츠풀 리소스는 직접 호스팅

## 12.4 최초 입력 지연(FID)
### 12.4.1 정의
순간적으로 몰린 엄청난 트래픽 때문에 웹사이트가 클릭이나 타이핑이 되지 않아 아무런 작업을 하지 못한 경험이 있을 것이다. 아무리 페이지가 빠르게 로딩되더라도 사용자가 클릭같은 상호작용을 할 수 없다면 사용자는 웹사이트가 느리다고 생각할 것이다.

웹페이지의 로딩 속도만큼 중요한 것이 웹사이트의 반응 속도다. 이러한 웹사이트의 반응성을 측정하는 지표가 바로 최초 입력 지연 (FID: First Input Delay)이다.

FID
> 사용자가 페이지와 처음 상호 작용할 때부터 해당 상호 작용에 대한 응답으로 브라우저가 실제로 이벤트 핸들러 처리를 시작하기까지의 시간을 측정한다.

=> 사용자가 얼마나 빠르게 웹페이지와의 상호작용에 대한 응답을 받을 수 있는지 측정하는 지표다. 모든 입력에 대해 측정하는 것이 아니며, 최초의 입력 하나에 대해서만 그 응답 지연이 얼마나 걸리는 판단한다.

### 12.4.2 의미
웹사이트 내부의 이벤트가 반응이 늦어지는 이유는 대부분 해당 입력을 처리해야 하는 브라우저의 메인 스레드가 바쁘기 때문이다. 

이 메인 스레드가 바쁜 이유는 무언가 대규모 렌더링이 일어나고 있거나, 대규모 자바스크립트 파일을 분석하고 실핸하는 등 다른 작업을 처리하는 데 리소스를 할애하고 있기 때문이다. 

자바스크립트 실행 환경을 `싱글 스레드`이기 때문에 자바스크립트가 이벤트 리스너와 같은 다른 작업을 실행할 수 없어 지연이 발생한다.

즉, 이벤트가 발생하는 시점에 최대한 메인 스레드가 다른 작업을 처리할 수 있도록 여유을 만들어 둬야 사용자에게 빠른 반응성을 보장할 수 있다.

- 사용자의 최초 입력
    - 반응성에 해당하는 클릭, 터치, 타이핑 등 사용자의 개별 입력에 초점
    - 스크롤, 핀치 투 줌 등은 애니메이션으로 분류해 측정 대상에서 제외

- 구글에서 말하는 사용자 경험, RAIL 가운데 R에 해당하는 응답에 초점을 맞추고 있다.
    - Response: 사용자의 입력에 대한 반응 속도 (50ms 미만으로 처리할 것)
    - Animation: 애니메이션의 각 프레임을 10ms 이하로 생성할 것
    - Idle: 유휴 시간을 극대화해 페이지가 50ms 이내에 사용자 입력에 응답하도록 할 것
    - Load: 5초 이내에 콘텐츠를 전달하고 인터랙션을 준비할 것

=> FID는 화면이 최초에 그려지고 난 뒤, 사용자가 웹페이지에서 클릭 등 상호작용을 수행했을 때 메인 스레드가 이 이벤트에 대한 반응을 할 수 있을 때까지 걸리는 시간을 의미한다.

### 12.4.3 예제
최초 이벤트 발생으로부터 해당 이벤트의 핸들러가 실행되는 순간까지 사이의 기간만 측정한다. 즉, 이벤트 핸들러가 완료되는 데 걸리는 시간은 측정하지 않는다. 

이벤트 핸들러의 실행 시간을 측정하고 싶다면 Event Timing API를 사용하는 것이 좋다.


### 12.4.4 기준 점수
최초 입력 지연의 좋은 점수를 얻기 위해서는 **100ms 이내**로 응답이 와야하며, 300ms 이내인 경우 보통, 그 이하의 경우에는 나쁨으로 처리된다.

### 12.4.5 개선 방안
메인 스레드에 이벤트를 실행할 여유를 줘야 한다.

#### 실행에 오래 걸리는 긴 작업을 분리
긴 작업(long task)이란 실행을 완료하는 데 오래 걸리는 작업 (크롬 기준 50ms 이상)

꼭 웹페이지에서 해야 하는 긴 작업이 있다면, 여러 개로 분리해 처리하는 것이 좋다. 웹페이지 최초 로딩에 필요하지 않은 내용을 나중에 불러오는 것도 포함된다.

예를들어 웹페이지에서 팝업이나 레이어가 있을 경우, 사용자의 액션으로 인해 노출되는 요소들은 당장의 로딩에 필요하지 않은 리소스다. 이러한 리소스는 리액트의 Suspense와 lazy를, 혹은 Next.js의 dynamic을 이용해 나중에 불러오게 할 수 있다.

#### 자바스크립트 코드 최소화
현대의 번들링 도구는 코드 번들링에 필요한 코드만 모아서 최종 프로덕션 자바스크립트 코드를 생성한다. 개발자가 작성한 코드라도 빌드 과정에서 사용되지 않는 코드로 간주되면 번들링에서 제거된다. 여전히 사용되지 않는 필요 없는 코드가 존재할 수 있고, 이는 크롬 개발자 도구 > 커버리지를 통해 확인할 수 있다.

- 지연 로딩 기법
- 폴리필(polyfill)의 크기는 제법 크므로 폴리필이 필요한 환경인지, 꼭 필요한 폴리필인지 확인해 봐야한다.
    - 폴리필이란 브라우저에서 지원하지 않는 기능을 사용하기 위해 웹페이지에서 직접 구현하고 집어넣는 코드를 의미한다.
    - 바벨을 사용한다면 @babel/preset-env 사용하고, SWC를 사용한다면 별도로 처리하지 않아도 된다.

#### 타사 자바스크립트 코드 실행의 지연
Google Analytics나 Firebase와 같이 웹페이지 통계 집계를 위해 제3자가 만든 타사 스크립트를 넣는 경우도 많다. 이 코드의 실행으로 인해 메인 스레드가 잠시 점유되고, 이로 인해 사용자에게 좋지 않은 반응성을 제공될 수가 있다.

이러한 타사 스크립트는 대부분 웹페이지 로드에 중요한 자원이 아니므로 <script>의 async나 defer을 이용해 지연 불러오기를 하는 것이 좋다.


## 12.5 누적 레이아웃 이동(CLS)
### 12.5.1 정의
웹 사이트에서 로딩이 끝난 줄 알고 무언가를 클릭하려고 했는데 그 사이 다른 요소가 로딩되면서 원래 클릭하려고 했던 요소를 클릭하지 못 하는 경우가 있을 것이다. 이처럼 페이지의 생명주기 동안 발생하는 모든 예기치 않은 이동에 대한 지표를 계산하는 것이 바로 누적 레이아웃 이동(CLS)이다.

### 12.5.2 의미
리액트로 만들어진 웹사이트는 useEffect를 사용하며, useEffect는 렌더링이 한 번 끝난 이후에 콜백 함수는 실행하는 훅이다. useEffect가 많을수록 클라이언트에서 처리해야 하는 작업이 많아진다.

CLS은 사용자의 가시적인 콘텐츠에 영향을 미쳐야 하기 때문에 뷰포트 내부의 요소에 대해서만 측정한다.

점수를 계산할 때 포함되는 내용은 다음 점수의 곱과 같다.
- 영향분율: 레이아웃 이동이 발생한 요소의 전체 높이와 뷰포트 높이의 비율
- 거리분율: 뷰포트 대비 얼마나 이동했는지

### 12.5.3 예제

### 12.5.4 기준 점수
- 0.1이하: 좋음
- 0.25이하: 보통
- 0.25초과: 나쁨

### 12.5.5 개선 방안
#### 삽입이 예상되는 요소를 위한 추가적인 공간 확보
대부분의 큰 누적 레이아웃 이동은 클라이언트에서 삽입되는 동적인 요소로 인해 발생한다.

1. useLayoutEffect사용
useEffect대신 useLayoutEffect를 사용해서 해결할 수 있지만, 동기적으로 발생해 브라우저의 페인팅 작업에 영향을 미치기 때문에 로딩이 오래 걸리는 것과 같이 보일 수 있다. CLS를 막으려다 다른 모든 작업에 악 영향을 끼칠 수 있어서 신중하게 선택해야 한다.

2. 스켈레톤 UI 사용
스켈레톤 UI를 먼저 나타내는 방법이 있지만 해당 영역이 뜨지 않는 케이스가 있다면 CLS현상을 방지하기 어렵다.

3. 서버사이드 렌더링
제일 좋은 방법으로 서버에서 동적인 요소의 유무를 사전에 판단해 클라이언트에 HTML을 미리 제공해 준다면 깔끔하게 처리될 것이다.

#### 폰트 로딩 최적화
폰트로 인해 발생할 수 있는 문제는 크게 두 가지다.

- FOUT: HTML문서에서 지정한 폰트가 보이지 않고 대체 기본 폰트로 보이고 있다가 뒤늦게 폰트가 적용되는 현상
- FOIT: HTML문서에서 지정한 폰트가 보이지 않고, 기본 폰트도 없어서 텍스트가 없는 채로 있다가 뒤늦게 폰트가 로딩되면서 페이지에 렌더링되는 현상

-> <link>의 preload 사용, font-family: optional; 

#### 적절한 이미지 크기 설정
1. width: 100%; height: auto;와 함께 width, height를 원하는 비율로 지정하기

2. 반응형 이미지를 사용하고 싶다면 srcset 속성 사용하기

### 12.5.6 핵심 웹 지표는 아니지만 성능 확인에 중요한 지표들
#### 최초 바이트까지의 시간(Time To First Byte, TTFB)
브라우저가 웹페이지의 첫 번째 바이트를 수신하는데 걸리는 시간

즉, 페이지를 요청했을 때 요청이 완전히 완료되는 데 걸리는 시간이 아닌 최초의 응답이 오는 바이트까지가 얼마나 걸리는지를 측정하는 지표다.

특히 서버 사이드 렌더링을 하고 있는 경우 주의 깊게 봐야한다. 서버에서 첫 번째 HTML을 만들기 위해 해야 하는 작업이 많거나 느릴수록 TTFB의 시간이 길어진다.

개선 방안
- 페이지를 그리는 데 중요한 내용만 SSR
- 가까운 곳에 서버 위치
- 리액트 SSR이라면 renderToNodeStream이나 renderToStaticNodeStream과 같은 스트리밍 API를 사용

#### 최초 콘텐츠풀 페인트(FCP: First Contentful Paint)
페이지가 로드되기 시작한 시점부터 페이지 콘텐츠의 일부가 화면에 렌더링될 때까지의 시간을 측정한다. 웹사이트에 접속한 순간부터 페이지에 뭐라도(텍스트, 이미지, svg 등) 뜨기 시작한 시간을 의미한다.

기준 점수
- 1.8초 이내: 좋음
- 3.0초 이내: 보통
- 3.0초 초과: 나쁨

개선 방안
- TTFB 개선
- 렌더링을 가로막는 리소스 최소화
- Above the Fold에 대한 최적화: 웹에서 최초에 스크롤을 굳이 하지 않아도 보이는 영역을 Above the Fold라고 한다. 게으른 로딩, 스크립트에 의존해 요소가 렌더링 되는 것을 피해야 한다.
- 페이지 리다이렉트 최소화
- DOM 크기 최소화: 구글 기준, 전체 DOM 노드는 1500개 미만, 깊이 32단계 정도까지만, 부모 노드는 자식 노드를 60개정도만 가지고 있어야 한다.

## 12.6 정리
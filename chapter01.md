# 01장 리액트 개발을 위해 꼭 알아야 할 자바스크립트 

- [1.1 자바스크립트의 동등 비교](#1.1-자바스크립트의-동등-비교)
    - [1.1.1 자바스크립트의 데이터 타입](#1.1.1-자바스크립트의-데이터-타입)
    - 1.1.2 값을 저장하는 방식의 차이
    - 1.1.3 자바스크립트의 또 다른 비교 공식, Object.is
    - 1.1.4 리액트에서의 동등 비교
- 1.2 함수
    - 1.2.1 함수란 무엇인가?
    - 1.2.2 함수를 정의하는 4가지 방법
    - 1.2.3 다양한 함수 살펴보기
    - 1.2.4 함수를 만들 때 주의해야 할 사항
- 1.3 클래스
- 1.4 클로저
    - 1.4.1 클로저의 정의
    - 1.4.2 변수의 유효 범위, 스코프
    - 1.4.3 클로저의 활용
    - 1.4.4 주의할 점
- 1.5 이벤트 루프와 비동기 통신의 이해
    - 1.5.1 싱글 스레드 자바스크립트
    - 1.5.2 이벤트 루프란?
    - 1.5.3 태스크 큐와 마이크로 태스크 큐
- 1.6 리액트에서 자주 사용하는 자바스크립트 문법
    - 1.6.1 구조 분해 할당
    - 1.6.2 전개 구문
    - 1.6.3 객체 초기자
    - 1.6.4 Array 프로토타입의 메서드: map, filter, reduce, forEach
    - 1.6.5 삼항 조건 연산자
- 1.7 선택이 아닌 필수, 타입스크립트
    - 1.7.1 타입스크립트란?
    - 1.7.2 리액트 코드를 효과적으로 작성하기 위한 타입스크립트 활용법
    - 1.7.3 타입스크립트 전환 가이드


## 1.1 자바스크립트의 동등 비교
리액트의 가상 DOM과 실제 DOM의 비교, 리액트 컴포넌트가 렌더링할지를 판단하는 방법, 벼수나 함수의 메모이제이션 등 모든 작업은 자바스크립트의 동등 비굘르 기반으로 한다.
### 1.1.1 자바스크립트의 데이터 타입
자바스크립트의 데이터 타입은 `원시 타입`과 `객체 타입`으로 나뉜다.

#### 원시 타입
1. Undefined 
    - 선언한 후 값을 할당하지 않은 변수
    - 값이 주어지지 않은 인수에 자동으로 할당되는 값
2. Null 
    - 아직 값이 없거나 비어 있는 값
    - typeof null 은 'object'가 출력된다는 것 주의 (호환성 이유)
> undefined는 선언되었지만 할당되지 않은 값이고, null은 명시적으로 비어있음을 나타내는 값으로 사용
3. Boolean
    - 참(true), 거짓(false)만을 가질 수 있는 데이터타입
    - 조건문 내부에서 마치 true, false처럼 취급되는 truthy, falsy값이 존재
        ```
        // falsy: false, 0, -0, 0n, 0x0n, NaN, “”, ‘’, `` (공백이 없는 빈 문자열), null, undefined
        // truthy: falsy외에 모든 것이 truthy (객체와 배열은 내부 값 존재 여부와 상관없이 truthy임 주의)
        ```
4. Number 
    - `-(2^53-1)`과 `2^53-1` 사이의 값 저장
    - 진수별로 값을 표현해도 모둔 10진수로 해석되어 동일한 값으로 표시
5. Bigint 
    - Number가 다룰 수 있는 숫자 크기의 제한을 극복하기 위해 등장
    - 끝에 n을 붙이거나 BigInt 함수를 사용
6. String 
    - 백틱을 사용해서 표현한 문자열을 템플릿 리터럴이라고 하는데, 같은 문자열을 반환하지만 줄바꿈이 가능하고, 문자열 내부에 표현식을 쓸 수 있다는 차이가 있음
    - 문자열은 원시 타입이므로 변경 불가능 (index 접근은 가능하지만 값을 수정할 수는 없음)
7. Symbol 
    - ES6, 중복되지 않는 고유한 값
    - 심벌 함수 `Symbol()`을 사용해야 만들 수 있음

#### 객체 타입
- 7가지 원시 타입 이외의 모든 것이 객체타입이다. 즉 자바스크립트를 이루고 있는 대부분의 타입이 객체 타입에 속한다.
- 배열, 함수, 정규식, 클래스 등이 여기에 포함된다.

### 1.1.2 값을 저장하는 방식의 차이
원시 타입과 객체 타입의 주된 차이점은 값을 저장하는 방식에 있다. 이 차이는 동등 비교시에 영향을 미치는 원인이 된다.
- 원시 타입: 불변 형태의 값으로 저장되며, 변수 할당 시점에 메모리 영영을 차지하고 저장한다. 값을 복사해 전달한다.
- 객체 타입: 프로퍼티를 삭제, 추가, 수정할 수 있어 변경 가능한 형태로 저장된다. 값을 복사할 때 참조를 전달한다.

### 1.1.3 자바스크립트의 또 다른 비교 공식, Object.is
[mdn - Object.is](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Object/is)

#### == (Equality Operator)
값이 동등한지 여부를 검사하고 자동 형 변환이 이뤄짐

#### === (Strict Equality Operator)
값과 타입이 모두 동일한지 여부를 검사
형 변환이 없이 엄격한 비교를 수행

#### Object.is
=== 와 유사하지만 Object.is가 좀 더 개발자가 기대하는 방식으로 정확히 비교한다.
```
-0 === +0; // true
Object.is(-0, 0); // false

Number.NaN === NaN; // false
Object.is(Number.NaN, NaN); // true

NaN === 0 / 0; // false
Object.is(NaN, 0 / 0); // true
```
위와 같이 특별한 사항에서 동등 비교 ===가 가지는 한계를 극복하기 위해 만들었으나 여전히 객체 간 비교에 있어서는 ===와 동일하게 동작하는 것을 알 수 있다.

### 1.1.4 리액트에서의 동등 비교
리액트에서 사용하는 동등 비교는 Object.is이며 ES6에서 제공하는 기능이기 때문에 폴리필을 함께 사용한다.

[shallowEqual](https://github.com/facebook/react/blob/3e00e58a6ac7f73a3660f31d3129fb06d344167e/packages/shared/shallowEqual.js)

Object.is로 먼저 비교를 수행한 다음에 Object.is에서 수행하지 못하는 비교, 즉 **객체 간 얕은 비교**를 한 번 더 수행

객체의 얕은 비교만 구현한 이유는 JSX props는 객체이고,
리액트는 props에서 추출한 값들을 기준으로 렌더링을 수행하므로,  props만 일차적으로 비교하면 되기 때문이다. 대부분의 상황에서는 얕은 비교로 충분하다.

이를 재귀적으로 비교하려고 할 경우 객체 안에 객체가 몇 개까지 있을지 알 수 없으므로 성능에 악영향을 미칠 것이다.

## 1.2 함수
함수형 컴포넌트를 작성할 때 화살표 함수와 일반 함수를 혼재해서 쓰는 경우가 많다. 함수의 다양한 형태와 차이점을 살펴보자.

### 1.2.1 함수란 무엇인가?
작업을 수행하거나 값을 계산하는 등의 과정을 표현하고, 이를 하나의 블록으로 감싸서 실행 단위로 만들어 놓은 것

### 1.2.2 함수를 정의하는 4가지 방법
#### 1. 함수 선언문
자바스크립트에서 함수를 선언할 때 가장 일반적으로 사용하는 방식
```
function add(a, b) {
  return a + b;
}
```
(기명 함수 리터럴은 선언문으로도, 표현식으로도 사용될 수 있다.)

함수 선언문은 함수 호이스팅이 발생한다.
> 함수의 호이스팅: 함수에 대한 선언을 실행 전에 미리 메모리에 등록하는 작업


#### 2. 함수 표현식
- 함수를 변수에 할당하는 방식
- 자바스크립트의 함수는 **일급 객체**여서 함수 표현식이 가능하다
> 일급 객체: 다른 객체들에 일반적으로 적용 가능한 연산을 모두 지원하는 객체
```
const sum = function (a, b) {
  return a + b;
};
```
함수 표현식에 할당하려는 함수의 이름은 생략하는 것이 일반적이다. 이 함수 이름은 실제 함수 내부에서만 유효한 식별자일 뿐, 함수를 외부에서 호출하는 데에는 사용할 수 없는 식별자이기 때문이다.

함수 표현식은 변수 호이스팅이 발생한다.

#### 3. Function 생성자
- 함수의 몸통을 모두 문자열로 작성, 함수의 클로저가 생성되지 않음 등의 이유로 권장되지 않은 방식
- eval만큼이나 실제 코딩에서 사용되지 않은 방법
```
const add = new Function("a", "b", "return a + b");
```

#### 4. 화살표 함수
- ES6에서 새롭게 추가된 함수 생성 방식
- function이라는 키워드 대신 =>를 사용해서 편리하다
```
const add = (a, b) => {
  return a + b;
};

const add = (a, b) => a + b;
```

앞서 언급한 함수 생성 방식들과의 차이점

1. constructor를 사용할 수 없다.
생성자 함수로 화살표 함수를 사용하는 것은 불가능하다.
```
const Car = (name) => {
  this.name = name;
};

// TypeError: Car is not a constructor
const myCar = new Car("하이");
```
2. argument가 존재하지 않는다.
> arguments: 함수에 전달된 인수에 해당하는 Array 형태의 객체
```
function hello() {
  console.log(arguments);
}

// Arguments(3) [ ... ]
hello(1, 2, 3);


const hi = () => {
  console.log(arguments)
};

// Uncaught ReferenceError: arguments is not defined
hi(1, 2, 3)
```

3. 함수 자체의 바인딩(this)를 갖지 않는다.
> this: 자신이 속한 객체나 자신이 생성할 인스턴스를 가리키는 값

this는 화살표 함수 이전까지는 함수를 정의할 때가 아니라, **함수가 호출될 때** 동적으로 결정된다.

만약 일반 함수로서 호출된 경우 함수 내부의 this는 전역 객체를 가리키게 된다.

그러나 화살표 함수는 이와 달리 함수 자체의 바인딩을 갖지 않는다. 화살표 함수 내에서 this를 참조하면 **상위 스코프의 this를 따르게** 된다.

일반 함수는 호출하는 런타임 시점에 결정되는 this를 따르고, 화살표 함수는 this가 선언되는 시점에 이미 상위 스코프로 결정돼 있다. 이처럼 선언 시점에 결정된다는 큰 차이점이 있기 때문에 일반 함수의 축약형이라고 보기엔 무리가 있다.

### 1.2.3 다양한 함수 살펴보기
### 1.2.4 함수를 만들 때 주의해야 할 사항
## 1.3 클래스
## 1.4 클로저
### 1.4.1 클로저의 정의
### 1.4.2 변수의 유효 범위, 스코프
### 1.4.3 클로저의 활용
### 1.4.4 주의할 점
## 1.5 이벤트 루프와 비동기 통신의 이해
### 1.5.1 싱글 스레드 자바스크립트
### 1.5.2 이벤트 루프란?
### 1.5.3 태스크 큐와 마이크로 태스크 큐
## 1.6 리액트에서 자주 사용하는 자바스크립트 문법
### 1.6.1 구조 분해 할당
### 1.6.2 전개 구문
### 1.6.3 객체 초기자
### 1.6.4 Array 프로토타입의 메서드: map, filter, reduce, forEach
### 1.6.5 삼항 조건 연산자
## 1.7 선택이 아닌 필수, 타입스크립트
### 1.7.1 타입스크립트란?
### 1.7.2 리액트 코드를 효과적으로 작성하기 위한 타입스크립트 활용법
### 1.7.3 타입스크립트 전환 가이드

## 1.1 자바스크립트의 동등 비교
